% Term Project
% CSCI: 431 - Computer Vision
% Fall 2022
function class = Classify_Ivy( filename )

    addpath('./IMAGES_OTHER_PLANTS/');
    addpath('./IMAGES_of_POISON_IVY/');

    % circle mask helper function
    % calculates a circle in the middle of image im
    % the radius of the circle is dependent on radius_factor which divides
    % the full radius by a number to make the circle smaller
    function mask = circle_mask( im, radius_factor )
        
        % [row dimension, column dimension]
        dims = size(im);
        % the pixel in the very center of the image [x, y]
        center = round( dims( 1:2 ) / 2 );

        % info of our circle [row location, col location, circle radius]
        ci = [center(1), center(2), round(center(1) / radius_factor)]; 
        % grid wrt our circle location
        [x,y] = ndgrid( ( 1:dims(1) ) - ci(1),( 1:dims(2)) - ci(2) );
        % get the pixels inside the circle radius ci(3)
        mask = uint8((x.^2 + y.^2) < ci(3)^2);


    end

    
    % three channel subplot helper function
    function plot_three_channels( im )

        figure;
        subplot(2, 2, 1);
        imagesc(im);
        title("Original");
        subplot(2, 2, 2);
        imagesc(im(:,:,1));
        title("Channel 1");
        subplot(2, 2, 3);
        imagesc(im(:,:,2));
        title("Channel 2");
        subplot(2, 2, 4);
        imagesc(im(:,:,3));
        title("Channel 3");

    end

    % KMEANS Helper function
    % Perform KMeans Clustering on image im resulting in k clusters
    % We will utilize HSV and CIELAB* color spaces to assist us in finding
    % the leaf well
    function [cluster_id, centers] = do_kmeans( im, k )

        % row vectors, column vectors of our image - tells us where a pixel is
        % [xs, ys] = meshgrid( 1:s_dims(1), 1:s_dims(2) );
        
        % Convert our image to CIELAB 
        im_lab = rgb2lab( im );
    
        % Extract luminance, a*, and b* LAB channels
        lum = im_lab(:,:,1);
        a_star = im_lab(:,:,2);
        b_star = im_lab(:,:,3);
    
        % Extract hue, saturation, and value HSV channels
        hsv = rgb2hsv( im );
        hue = hsv(:,:,1);
        % sat = hsv(:,:,2);
        val = hsv(:,:,3);

        % Extract Cr value from YCbCr space that also seems to help well in
        % isolating the leaf from its background
        ycbcr = rgb2ycbcr(im);
        cr = ycbcr(:,:,3);

        % plot_three_channels(im_lab);
        % plot_three_channels(hsv);
        % plot_three_channels(ycbcr);
        
        % Attributes input to k-means, utilizing the channels from above as
        % our input attributes
        attributes = [hue(:), val(:), lum(:), a_star(:), b_star(:), cr(:)];

        % Perform kmeans clustering on image returning k clusters
        [cluster_id, centers] = kmeans(attributes, k, 'MaxIter',250);

    end

    % read in image
    im = ( imread( filename ) );
    
    mask = circle_mask(im, 1);
    im_leaf_center = uint8(zeros(size(im)));
    % mask each of our rgb channels
    im_leaf_center(:,:,1) = im(:,:,1).*mask;
    im_leaf_center(:,:,2) = im(:,:,2).*mask;
    im_leaf_center(:,:,3) = im(:,:,3).*mask;

    % kmeans takes way too long on the full resolution image
    im_smaller = im_leaf_center( 3:3:end, 3:3:end, : );

    % add 75% more saturation to image
    im_smaller_hsv = rgb2hsv(im_smaller);
    im_smaller_hsv(:, :, 2) = im_smaller_hsv(:, :, 2) * 1.75;
    im_smaller_sat = hsv2rgb(im_smaller_hsv);
    
    % unsharp masking filter - enhance sharpness of leaf vs. blur before we
    % go looking for strong edges
    im_sat_sharp = imsharpen(im_smaller_sat);

    % edge filter
    fltr_dIdy       = [ -1  -2  -3  -2  -1 ;
                         0   0   0   0   0 ;
                         0   0   0   0   0 ;
                         0   0   0   0   0 ;
                        +1  +2  +3  +2  +1 ] / (4*9);  

    % image a* - we want to find significant edges in this domain
    im_sat_lab = rgb2lab(im_sat_sharp);
    im_sat_a = im_sat_lab(:,:,2);

    % calculate edge strengths 
    dIdy = imfilter( im_sat_a, fltr_dIdy, 'same', 'repl' );
    dIdx = imfilter( im_sat_a, fltr_dIdy.', 'same', 'replicate');
    dImag           = sqrt( dIdy.^2  + dIdx.^2 );

    % extract edges stronger than 3 in the x and y direction
    im_edges = ( dIdy         < -1 ) | ( dIdx < -1);
    im_edges = ( dImag > 3 );

%     b_dil = imdilate(im_edges, strel('disk', 7));
%     b_fill = imfill(b_dil, 'holes');
%     b_fill = imdilate(b_fill, strel('disk', 5));
%     im_cropped_sat = im_smaller_sat.*repmat(b_fill,[1,1,3]);
    
    % perform kmeans on our current processed image
    [cluster_id, centers] = do_kmeans( im_sat_sharp, 7 );
    centers_colors = lab2rgb(centers(:,3:5));
    q_dims = size( im_sat_sharp );
    im_new = reshape(cluster_id, q_dims(1), q_dims(2)); 
    % colormap(centers_colors);
    

    % get all clusters with a* significantly negative
    new_cen = [centers(:, 1)*10 centers(:, 2)*10 centers(:, 3) centers(:, 4) centers(:, 5)];
    [green_rows, ~] = find(new_cen(:, 4) < -10);
    green_cen = [];
    for i = 1 : size(green_rows)
        green_cen = [green_cen ; new_cen(green_rows(i), :)];
    end

    % which green cluster has the most pixels on target
    green_cluster = 0;
    greatest_num_green_pix = 0;
    for i = 1 : size(green_cen)
    
        [~, cluster] = ismember(green_cen(i, :), new_cen, 'rows');
        im_green_new = (im_new == cluster);
        green_sum = sum(im_green_new(:));
        if green_sum > greatest_num_green_pix
            greatest_num_green_pix = green_sum;
            green_cluster = cluster;
        end
    
    end

    % if !green, !ivy
    if greatest_num_green_pix == 0
        fprintf("NOT Poison Ivy\n");
        return;
    end

    % our new im mask is the most significant green cluster
    im_new_leaf = (im_new == green_cluster);
    
    % Disk structuring element
    disk = strel('disk', 5);
    % Get rid of black specs on leaf
    im_dilate_leaf = imdilate(im_new_leaf, disk);
    % Make sure objects picked up are separated enough
    im_final_morph = imerode(im_dilate_leaf, disk);
    % Label and get number of our different blobs - 4 pixel connectivity
    [L, n] = bwlabel(im_final_morph, 4);
    
    im_final_preprocessed = zeros(size(im_final_morph));
    % loop through discovered blobs
    for d = 1 : n
        
        this_blob = (L == d);
        stats = regionprops(this_blob, 'all');
        if stats.Area < 10000
            continue;
        end

        % BoundingBox = [left, top, width height]
        % blob_wid = stats.BoundingBox(3);
        % blob_hei = stats.BoundingBox(4);
        
        im_final_preprocessed = im_final_preprocessed | this_blob;

    end
    % display our fully preprocessed leaves
    %figure;
    %imagesc(im_final_preprocessed);
    %title(filename);
    %colormap('gray');

    % ---- end of preprocessing ---- beginning of classifying ----
    
    % separate leaves by performing a circle mask in the center of the
    % image
    mask = ~circle_mask(im_final_preprocessed, 2.5);
    im_sep_middle = (zeros(size(im_final_preprocessed)));
    % apply the mask to our im_final_pre blob
    im_sep_middle(:,:) = im_final_preprocessed(:,:).*mask;

    % once again pick apart clusters and discard any small area clusters
    % like stems
    [clus, num] = bwlabel(im_sep_middle, 4);
    im_clus_after_mid = zeros(size(im_final_preprocessed));
    for d = 1 : num
        this_clus = (clus == d);
        stats = regionprops(this_clus, 'all');
        if stats.Area < 12000
            continue
        end
        im_clus_after_mid = im_clus_after_mid | this_clus;
    end

    % if we are left with 3 leaves, it is most likely poision ivy
    leaf = imfill(im_final_preprocessed, 'holes');
    im_skel = bwmorph(leaf, 'skel', Inf);
    im_skel(:,:) = im_skel(:,:).*~circle_mask(im_final_preprocessed, 5);
    [skel_clus, skel_num] = bwlabel(im_skel, 8);

    % count how many leaves we have based on how many skeletons we have
    skel_count = 0;
    for d = 1 : skel_num
        this_clus = (skel_clus == d);
        stats = regionprops(this_clus, 'all');
        if stats.Area < 300
            continue
        end
        skel_count = skel_count + 1;
    end

    % if each leaf has only 1-2 thumbs (corners), ivy
    
    im_leaf_edges = (imdilate(leaf, strel('disk', 10)) & im_edges);
    [edge_clus, edge_num] = bwlabel(im_leaf_edges, 8);
    im_edges_final = zeros(size(im_leaf_edges));
    for d = 1 : edge_num
        this_edge = (edge_clus == d);
        stats = regionprops(this_edge, 'Area');
        if stats.Area < 500
            continue
        end
        im_edges_final = im_edges_final | this_edge;
    end
    im_edges_final = imclose(im_edges_final, disk);
    % figure;
    % imagesc(im_edges_final);
    % corners = detectHarrisFeatures(im_edges_final, "MinQuality", 0.4);
    % corners = detectHarrisFeatures(im_edges_final, "MinQuality", 0.5);
    corners = detectHarrisFeatures(im_edges_final, "MinQuality", 0.6);
    %hold on;
    %plot(corners);
    %colormap("gray");
    %fprintf("-- %d %d %d ===", corners.Count, corners1.Count, corners2.Count);
    
    % here perform sort of a custom mahalanobis calculation..
    % mean corners we got from all IVY training data is ~40 with a standard
    % deviation of ~17.
    % therefore if corners is within 1 std dev of the mean 40, we will
    % classify this plant as IVY
    % this is also a good risk management indicator in case we are unsure
    % we want to be safe and be somewhere around this criteria

    % all in all here is our classifier - we also add risk management to
    % the leaf count, if it is in the ballpark of 3 we will say it is
    % poison ivy otherwise it is not - err on the side of caution!!!!
    % if it is out of both ballparks it is false
    if ( skel_count < 2 ) || ( skel_count > 4 )
        class = false;
    elseif ( ( corners.Count < 23 ) || ( corners.Count > 57 ) ) %&& ...
           %( ( skel_count < 2 ) || ( skel_count > 4 ) )
        class = false;
    else
        class = true;
    end
end