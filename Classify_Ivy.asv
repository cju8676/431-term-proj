% Term Project
% CSCI: 431 - Computer Vision
% Fall 2022
function Classify_Ivy( filename )

    addpath('./IMAGES_OTHER_PLANTS/');
    addpath('./IMAGES_of_POISON_IVY/');

    % read in image
    im = ( imread( filename ) );
    
    % [row dimension, column dimension]
    dims = size(im);
    % the pixel in the very center of the image [x, y]
    center = round( dims( 1:2 ) / 2 );

    % info of our circle [row location, col location, circle radius]
    ci = [center(1), center(2), center(1)]; 
    % grid wrt our circle location
    [xx,yy] = ndgrid( ( 1:dims(1) ) - ci(1),( 1:dims(2)) - ci(2) );
    % get the pixels inside the circle radius ci(3)
    mask = uint8((xx.^2 + yy.^2) < ci(3)^2);
    im_leaf_center = uint8(zeros(size(im)));
    % mask each of our rgb channels
    im_leaf_center(:,:,1) = im(:,:,1).*mask;
    im_leaf_center(:,:,2) = im(:,:,2).*mask;
    im_leaf_center(:,:,3) = im(:,:,3).*mask;
%     figure;
%     imagesc(im_leaf_center);

    % kmeans takes way too long on the full resolution image
    im_smaller = im_leaf_center( 3:3:end, 3:3:end, : );
    s_dims = size(im_smaller);
    % row vectors, column vectors of our image - tells us where a pixel is
    [xs, ys] = meshgrid( 1:s_dims(1), 1:s_dims(2) );

    im_smaller_hsv = rgb2hsv(im_smaller);
    % 75% more saturation:
    im_smaller_hsv(:, :, 2) = im_smaller_hsv(:, :, 2) * 1.75;
    im_smaller_sat = hsv2rgb(im_smaller_hsv);
    figure;
    imagesc(im_smaller_sat);

    % edge filter
    fltr_dIdy       = [ -1  -2  -3  -2  -1 ;
                     0   0   0   0   0 ;
                     0   0   0   0   0 ;
                     0   0   0   0   0 ;
                    +1  +2  +3  +2  +1 ] / (4*9);   

    % image a* - we want to find significant edges in this domain
    im_sat_lab = rgb2lab(im_smaller_sat);
    im_sat_a = im_sat_lab(:,:,2);
    figure;
    imagesc(im_sat_a);
    dIdy = imfilter( im_sat_a, fltr_dIdy, 'same', 'repl' );
    dIdx = imfilter( im_sat_a, fltr_dIdy.', 'same', 'replicate');
    figure;
    imagesc(dIdx);
    imagesc(dIdy);
%     dIangle         = atan2( -dIdy, dIdx ) * 180 / pi;



    b_im_edges_horiz     = ( dIdy         < -4 ) | ( dIdx < -4);
    b_dil = imdilate(b_im_edges_horiz, strel('disk', 5));

    % if theres a b_dil point between a given pixel and the center point
    % then remove it - consider it outside of our leaf boundary
    sat_size = size(im_smaller_sat);
    sat_center = round( sat_size( 1:2 ) / 2 );
    im_finalized_sat = zeros(size(im_smaller_sat));
    % loop through pixels in our image
    for row = 1 : size(im_smaller_sat, 1)
        for col = 1: size(im_smaller_sat, 2)
            % skip already blacked out pixels for efficiency --------------
            x1 = [row, col];
            % get line between pixel and center - y=mx + b form
            mb = [[1; 1] x1(:)]\sat_center(:);
            pause(1);
            % are there any 1's in b_dil on that line?
            % if so continue
            % if not then add to finalized
        end
    end

    % Convert our image to CIELAB 
    im_lab = rgb2lab(im_smaller_sat);

    % Store luminance, a*, and b* values to be used for k-means
    lum = im_lab(:,:,1);
    a_star = im_lab(:,:,2);
    b_star = im_lab(:,:,3);
    
    % Attributes input to k-means, space variables weighted by 1/15
    attributes = [xs(:)/10, ys(:)/10, lum(:), a_star(:), b_star(:)];
    % Timer Start
    tic;
    % Perform kmeans clustering on image
    [cluster_id, centers] = kmeans(attributes, 8, 'MaxIter',250);
    % Timer Stop
    toc;

    % Show our resulting clustered image by reshaping the clusters we got
    % from k-means
    figure;
    im_new = reshape(cluster_id, s_dims(1), s_dims(2));
    imagesc(im_new);
    centers_colors = lab2rgb(centers(:,3:5));
    colormap(centers_colors);
%         title("Clustered Image - k = 5, wt = 1/15")
    colorbar;
    drawnow;
    axis image;

    % get all clusters with a* significantly negative
    new_cen = [centers(:, 1)*10 centers(:, 2)*10 centers(:, 3) centers(:, 4) centers(:, 5)];
    [green_rows, ~] = find(new_cen(:, 4) < -10);
    green_cen = [];
    for i = 1 : size(green_rows)
        green_cen = [green_cen ; new_cen(green_rows(i), :)];
    end

    % which green cluster has the most pixels on target
    green_cluster = 0;
    greatest_num_green_pix = 0;
    for i = 1 : size(green_cen)
    
        [~, cluster] = ismember(green_cen(i, :), new_cen, 'rows');
        im_green_new = (im_new == cluster);
        green_sum = sum(im_green_new(:));
        if green_sum > greatest_num_green_pix
            greatest_num_green_pix = green_sum;
            green_cluster = cluster;
        end
    
    end

    % if !green, !ivy
    if greatest_num_green_pix == 0
        fprintf("NOT Poison Ivy\n");
        return;
    end

    % for now get the cluster with the highest green value
    % this == lowest a* valued cluster
    % centers colors is an array of clusters with rows
    % being [ x y lum a* b* ]
%         most_green = min(centers(:, 4));
%         [most_row, ~] = find(centers == most_green);
    im_new_leaf = (im_new == green_cluster);
%         [rgb_max, rgb_idx] = max(centers_colors);
%         im_new_leaf = (im_new == rgb_idx(2));
    
    % Disk structuring element
    disk = strel('disk', 5);
    % Get rid of black specs on leaf
    im_dilate_leaf = imdilate(im_new_leaf, disk);
    % Make sure objects picked up are separated enough
    im_final_morph = imerode(im_dilate_leaf, disk);
    % Label and get number of our different blobs - 4 pixel connectivity
    [L, n] = bwlabel(im_final_morph, 4);
    display(n);
    
    im_final_preprocessed = zeros(size(im_final_morph));
    % loop through discovered blobs
    for d = 1 : n
        
        this_blob = (L == d);
        
        stats = regionprops(this_blob, 'all');
%             display(stats);
        if stats.Area < 10000
            continue;
        end
        display(stats);
        % BoundingBox = [left, top, width height]
        blob_wid = stats.BoundingBox(3);
        blob_hei = stats.BoundingBox(4);
        
%             corners = detectHarrisFeatures(this_blob, 'MinQuality', 0.5);
%             figure;
%             display(corners);
        
        im_final_preprocessed = im_final_preprocessed | this_blob;
        imagesc(this_blob);
        hold on;
%             plot(corners.selectStrongest(50));
%         pause(2);
    end
    

        
    % if leaf != 3 leaves, !ivy
    
    % separate 
    dims_pre = size(im_final_preprocessed);
    % the pixel in the very center of the image [x, y]
    center_pre = round( dims_pre( 1:2 ) / 2 );
    % ci = center[row location, col location, radius]; 
    small_ci = [center_pre(1), center_pre(2), round(center_pre(1)/2.5)];
    % grid wrt our circle location
    [smallx,smally] = ndgrid( ( 1:dims_pre(1) ) - small_ci(1),( 1:dims_pre(2)) - small_ci(2) );
    % get the pixels inside the circle radius ci(3)
    mask = ~uint8((smallx.^2 + smally.^2) < small_ci(3)^2);
    im_sep_middle = (zeros(size(im_final_preprocessed)));
    % mask each of our rgb channels
    im_sep_middle(:,:) = im_final_preprocessed(:,:).*mask;
%     im_sep_middle(:,:,2) = im_final_preprocessed(:,:,2).*mask;
%     im_sep_middle(:,:,3) = im_final_preprocessed(:,:,3).*mask;
    
    figure;
    imagesc(im_sep_middle);

    % once again pick apart clusters and discard any small area clusters
    % like stems
    [clus, num] = bwlabel(im_sep_middle, 4);
    im_clus_after_mid = zeros(size(im_final_preprocessed));
    figure;
    for d = 1 : num
        this_clus = (clus == d);
        imagesc(this_clus);
        stats = regionprops(this_clus, 'all');
        display(stats);
%         pause(2);
        if stats.Area < 12000
            continue
        end
        im_clus_after_mid = im_clus_after_mid | this_clus;
    end
    % skeletonize
%     imagesc(im_clus_after_mid);
%     colormap("gray");
%     im_skel = bwmorph(im_clus_after_mid, "skeleton", 20);
%     figure;
%     imagesc(im_skel);

    [leaf_clus, final_num_leaves] = bwlabel(im_clus_after_mid, 4);
    if final_num_leaves ~= 3
        fprintf("NOT POISON IVY\n");
    else
        fprintf("3 leaves detected.\n");
    end

    % if each leaf has only 1-2 thumbs (corners), ivy
    

    % harris corners on final preprocessed
    corners = detectHarrisFeatures(im_clus_after_mid, 'MinQuality',0.3);
    imagesc(im_clus_after_mid);
    colormap("gray");
    hold on;
    plot(corners);
    % its going to have 2 strong corners that should be ommitted due to the
    % circle we created in the center


    


end